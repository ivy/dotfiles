# ============================================================================
# Mise activation (always — agents need tool management)
# ============================================================================
{{- if lookPath "mise" }}
eval "$(mise activate zsh)"
{{- end }}

# ============================================================================
# Agent/CI detection via envsense
# See: docs/adrs/0002-agent-optimized-shell-with-envsense.md
# ============================================================================
_is_automated=0
if command -v envsense >/dev/null && envsense check -q --any agent ci; then
  _is_automated=1
fi

# ============================================================================
# Interactive-only: plugins, prompt, and tool-replacement aliases
# Skipped for agents/CI to preserve standard command output and reduce startup
# ============================================================================
if (( ! _is_automated )); then

# Oh My Zsh framework
export ZSH="$HOME/.oh-my-zsh"

# shellcheck disable=SC2034
plugins=(
  git
  starship
)

source "$ZSH"/oh-my-zsh.sh

# Initialize atuin for magical shell history
{{- if lookPath "atuin" }}
eval "$(atuin init zsh)"
{{- end }}

{{- $zshAutoSuggestPath := joinPath .chezmoi.homeDir ".config/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh" }}
{{- if stat $zshAutoSuggestPath }}

# Speed-optimized zsh-autosuggestions loading
# All checks done at template generation time by chezmoi

# Pre-configure before loading for maximum speed
export ZSH_AUTOSUGGEST_USE_ASYNC=1
export ZSH_AUTOSUGGEST_MANUAL_REBIND=1  # We'll handle rebinding for vim mode
export ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE=20
export ZSH_AUTOSUGGEST_HISTORY_IGNORE="?(#c50,)"  # Ignore commands > 50 chars
export ZSH_AUTOSUGGEST_COMPLETION_IGNORE="* --help"  # Skip help completions

# Catpuccin theme support - optimized for Ghostty + tmux
if [[ "${TERM}" == "xterm-ghostty" ]] || [[ -n "${TMUX}" ]]; then
    # Ghostty and tmux support proper color sequences
    export ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=8'  # ANSI bright black adapts to theme
else
    # Fallback to neutral gray for other terminals
    export ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=244'
fi

# Load plugin
source {{ $zshAutoSuggestPath }}

# Custom vim mode integration
_zsh_autosuggest_bind_vim_mode() {
    # Clear default bindings
    bindkey -M viins '^[[C' forward-char  # Right arrow baseline
    bindkey -M viins '^[[D' backward-char # Left arrow baseline

    # Insert mode bindings
    bindkey -M viins '^F' vi-forward-word  # Ctrl+F: accept word
    bindkey -M viins '^E' vi-end-of-line   # Ctrl+E: accept to end
    bindkey -M viins '^]' autosuggest-accept  # Ctrl+]: accept full

    # Visual mode support
    bindkey -M vicmd '^]' autosuggest-accept
    bindkey -M visual '^]' autosuggest-accept

    # Quick accepts in normal mode
    bindkey -M vicmd 'L' vi-end-of-line
    bindkey -M vicmd 'A' vi-add-eol       # A should accept and go to end
}

# Apply vim bindings after plugin loads
_zsh_autosuggest_bind_vim_mode

# Speed hack: only fetch suggestions for commands > 2 chars
_zsh_autosuggest_should_fetch() {
    (( ${#BUFFER} > 2 ))
}

{{- end }}

# Enable Vi mode for command line editing
bindkey -v

# Tool-replacement aliases (change output format — breaks agent expectations)
{{- range .aliases.replacements }}
{{- if lookPath .tool }}
alias {{ .replaces }}='{{ .tool }}'
{{- end }}
{{- end }}
{{- range .aliases.custom }}
{{- if lookPath .tool }}
alias {{ .replaces }}='{{ .command }}'
{{- end }}
{{- end }}
{{- range .aliases.fallbacks }}
{{-   $replaces := .replaces }}
{{-   $matched := false }}
{{-   range .chain }}
{{-     if and (not $matched) (lookPath .tool) }}
{{-       $matched = true }}
alias {{ $replaces }}='{{ .command }}'
{{-     end }}
{{-   end }}
{{- end }}

# grep with extra flags (filename, line numbers)
alias grep='grep -Hn --color=auto'

# Suffix aliases - automatically open files by extension
alias -s md="glow --pager"

{{- $zshSyntaxHighlightPath := joinPath .chezmoi.homeDir ".config/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh" }}
{{- if stat $zshSyntaxHighlightPath }}

# ============================================================================
# Zsh Syntax Highlighting - MUST BE LOADED LAST (in interactive block)
# ============================================================================
# Speed-optimized configuration with compile-time checks

# Configure highlighters BEFORE loading the plugin
typeset -gA ZSH_HIGHLIGHT_HIGHLIGHTERS=(
    main 1
    brackets 1
    pattern 1
    cursor 0  # Disabled for performance
    root 0    # Disabled unless needed
)

# Performance optimization for large buffers
export ZSH_HIGHLIGHT_MAXLENGTH=20000

# Configure highlighting styles for catppuccin compatibility
typeset -gA ZSH_HIGHLIGHT_STYLES=(
    # Commands and builtins
    'builtin'                  'fg=blue'
    'command'                  'fg=green'
    'precommand'               'fg=green,underline'
    'alias'                    'fg=cyan'
    'function'                 'fg=cyan'

    # Paths
    'path'                     'fg=white,underline'
    'path_prefix'              'fg=white'
    'path_approx'              'fg=yellow'

    # Options and arguments
    'single-hyphen-option'     'fg=magenta'
    'double-hyphen-option'     'fg=magenta'

    # Quotes and globbing
    'single-quoted-argument'   'fg=yellow'
    'double-quoted-argument'   'fg=yellow'
    'dollar-quoted-argument'   'fg=yellow'
    'back-quoted-argument'     'fg=magenta'
    'globbing'                 'fg=cyan,bold'

    # Variables
    'assign'                   'fg=white'
    'parameter'                'fg=yellow'

    # Errors
    'unknown-token'            'fg=red,bold'
    'reserved-word'            'fg=magenta'
    'commandseparator'         'fg=white'

    # Brackets
    'bracket-level-1'          'fg=blue,bold'
    'bracket-level-2'          'fg=green,bold'
    'bracket-level-3'          'fg=magenta,bold'
    'bracket-level-4'          'fg=yellow,bold'
    'bracket-error'            'fg=red,bold'
)

# Custom patterns for common commands
typeset -gA ZSH_HIGHLIGHT_PATTERNS=(
    'rm -rf *'                 'fg=white,bold,bg=red'
    'sudo *'                   'fg=white,bold,bg=red'
)

# Load the plugin - MUST BE LAST
source {{ $zshSyntaxHighlightPath }}

# Ensure highlighting updates properly in vim modes
if [[ -n "$ZSH_HIGHLIGHT_VERSION" ]]; then
    # Force rehighlight on mode change
    function zle-keymap-select {
        zle && zle .reset-prompt && zle -R
    }

    # Ensure highlighting works in all vim modes
    zle -N zle-keymap-select
    zle -N zle-line-init
fi

{{- end }}

fi  # end (( ! _is_automated ))

# ============================================================================
# Always-available: PATH, functions, credential aliases
# These are needed by both humans and agents
# ============================================================================

# Add custom functions and completions directories to fpath and enable autoloading
fpath=(
  "$XDG_CONFIG_HOME/zsh/functions"
  "$XDG_CONFIG_HOME/zsh/completions"
  "${fpath[@]}"
)
autoload -Uz c

# Shadow codex command to auto-authenticate with 1Password
{{- if and (lookPath "op") (lookPath "codex") }}
alias codex='OPENAI_API_KEY=$(op read "op://Personal/openai-codex/credential") command codex'
{{- end }}

# Shortcut to use claude with API credentials from 1Password instead of normal login
{{- if and (lookPath "op") (lookPath "claude") }}
{{- if lookPath "claude-chill" }}
alias claude-api='ANTHROPIC_API_KEY=$(op read "op://Personal/claude-code/credential") claude-chill -- claude'
{{- else }}
alias claude-api='ANTHROPIC_API_KEY=$(op read "op://Personal/claude-code/credential") command claude'
{{- end }}
{{- end }}

{{- if and (lookPath "gh") (lookPath "mise") }}
# Wrap mise to use GitHub token from gh CLI
# Fixes "API rate limit exceeded" errors when mise downloads tools from GitHub releases
alias mise='GITHUB_TOKEN="$(gh auth token)" command mise'
{{- end }}

# Reload shell function - re-execs the exact same zsh binary
function reload! {
    # Find the actual zsh binary path using multiple fallback methods
    local zsh_path

    # Method 1: Linux - /proc/$$/exe symlinks to the actual executable
    if [[ -r /proc/$$/exe ]]; then
        zsh_path=$(readlink /proc/$$/exe)

    # Method 2: macOS/BSD - Use lsof to find the binary from open file descriptors
    # This works because the shell binary stays open as the executing process
    elif command -v lsof >/dev/null && zsh_path=$(lsof -p $$ -Fn | awk '/^n.*zsh$/{print substr($0,2); exit}'); then
        :  # zsh_path already set by command substitution

    # Method 3: Non-login shells - $0 contains the actual path when not a login shell
    # Login shells have $0 as "-zsh" but regular shells show the full path
    elif [[ $0 != -* ]]; then
        zsh_path=$0

    # Method 4: Login shell detection - If $0 starts with '-', we're in a login shell
    # Use getent/dscl to find the user's actual shell from the system database
    elif [[ $0 == -* ]]; then
        if command -v getent >/dev/null; then
            # Linux/Unix systems - query passwd database
            zsh_path=$(getent passwd "$USER" | cut -d: -f7)
        elif command -v dscl >/dev/null; then
            # macOS - query Directory Services
            zsh_path=$(dscl . -read "/Users/$USER" UserShell | awk '{print $2}')
        else
            # Fallback to $SHELL if system tools unavailable
            zsh_path=$SHELL
        fi

    # Method 5: Final fallback - Use $SHELL environment variable
    # This may not be the currently running shell but is the user's preferred shell
    else
        zsh_path=$SHELL
    fi

    exec "$zsh_path" "$@"
}

# Git-safe PATH modification - MUST RUN LAST
# Prepends .git/safe/../../bin to PATH for per-repository trusted binaries
# This allows each git repository to provide its own trusted executables
# Inspired by: https://thoughtbot.com/blog/git-safe
# Note: Placed at end to ensure it takes precedence over all other PATH modifications
export PATH=".git/safe/../../bin:$PATH"
